-- BracketAI Supabase Schema + RLS
-- Run this in Supabase SQL Editor.
-- Assumes anonymous MVP access using a client-provided session header.

begin;

create extension if not exists pgcrypto;

-- ----------
-- Utilities
-- ----------

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- Reads session id from JWT claim first, then from request header `x-session-id`.
-- Use this in client requests via supabase-js global headers.
create or replace function public.request_session_id()
returns text
language sql
stable
as $$
  select coalesce(
    nullif((current_setting('request.jwt.claims', true)::jsonb ->> 'session_id'), ''),
    nullif((current_setting('request.headers', true)::jsonb ->> 'x-session-id'), '')
  );
$$;

-- ----------
-- Tables
-- ----------

create table if not exists public.teams (
  id bigint generated by default as identity primary key,
  provider_team_id text,
  name text not null,
  short_name text not null,
  seed integer check (seed between 1 and 16),
  conference text not null,
  record text not null,
  wins integer not null,
  losses integer not null,
  offensive_rating numeric(5,1),
  defensive_rating numeric(5,1),
  net_rating numeric(5,1),
  strength_of_schedule numeric(5,2),
  three_point_pct numeric(4,1),
  turnover_rate numeric(4,1),
  turnovers_per_game numeric(4,1),
  rebound_margin numeric(4,1),
  ppg numeric(4,1),
  opp_ppg numeric(4,1),
  quad1_wins integer default 0,
  quad1_losses integer default 0,
  region text,
  logo_url text,
  primary_color text,
  secondary_color text,
  created_at timestamptz not null default now()
);

create table if not exists public.matchups (
  id bigint generated by default as identity primary key,
  provider_game_id text,
  round integer not null check (round between 1 and 6),
  round_name text not null,
  region text,
  game_number integer not null,
  team_a_id bigint references public.teams(id),
  team_b_id bigint references public.teams(id),
  team_a_seed integer,
  team_b_seed integer,
  ai_pick_team_id bigint references public.teams(id),
  ai_confidence text check (ai_confidence in ('high', 'medium', 'tossup', 'upset_alert')),
  ai_win_probability numeric(4,1),
  ai_rationale text,
  ai_scouting_report text,
  winner_id bigint references public.teams(id),
  created_at timestamptz not null default now()
);

create table if not exists public.user_brackets (
  id uuid primary key default gen_random_uuid(),
  session_id text not null,
  bracket_name text not null default 'My Bracket',
  strategy text not null default 'balanced' check (strategy in ('safe', 'chaos', 'balanced', 'custom')),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.user_picks (
  id bigint generated by default as identity primary key,
  bracket_id uuid not null references public.user_brackets(id) on delete cascade,
  matchup_id bigint not null references public.matchups(id),
  picked_team_id bigint not null references public.teams(id),
  followed_ai boolean not null default false,
  created_at timestamptz not null default now(),
  unique (bracket_id, matchup_id)
);

-- ----------
-- Indexes
-- ----------

create index if not exists idx_teams_seed on public.teams(seed);
create index if not exists idx_teams_region on public.teams(region);
create unique index if not exists ux_teams_provider_team_id
  on public.teams(provider_team_id)
  where provider_team_id is not null;

create index if not exists idx_matchups_round_game on public.matchups(round, game_number);
create index if not exists idx_matchups_region_round on public.matchups(region, round);
create index if not exists idx_matchups_team_a on public.matchups(team_a_id);
create index if not exists idx_matchups_team_b on public.matchups(team_b_id);
create unique index if not exists ux_matchups_provider_game_id
  on public.matchups(provider_game_id)
  where provider_game_id is not null;

create index if not exists idx_user_brackets_session_id on public.user_brackets(session_id);
create index if not exists idx_user_picks_bracket_id on public.user_picks(bracket_id);
create index if not exists idx_user_picks_matchup_id on public.user_picks(matchup_id);

-- ----------
-- Triggers
-- ----------

drop trigger if exists trg_user_brackets_updated_at on public.user_brackets;
create trigger trg_user_brackets_updated_at
before update on public.user_brackets
for each row
execute function public.set_updated_at();

-- ----------
-- Privileges
-- ----------

revoke all on public.teams from anon, authenticated;
revoke all on public.matchups from anon, authenticated;
revoke all on public.user_brackets from anon, authenticated;
revoke all on public.user_picks from anon, authenticated;

grant select on public.teams to anon, authenticated;
grant select on public.matchups to anon, authenticated;
grant select, insert, update, delete on public.user_brackets to anon, authenticated;
grant select, insert, update, delete on public.user_picks to anon, authenticated;

grant usage, select on all sequences in schema public to anon, authenticated;

-- ----------
-- RLS
-- ----------

alter table public.teams enable row level security;
alter table public.matchups enable row level security;
alter table public.user_brackets enable row level security;
alter table public.user_picks enable row level security;

-- Public read-only tables

drop policy if exists teams_read_all on public.teams;
create policy teams_read_all
on public.teams
for select
using (true);

drop policy if exists matchups_read_all on public.matchups;
create policy matchups_read_all
on public.matchups
for select
using (true);

-- user_brackets scoped to request_session_id()

drop policy if exists user_brackets_select_own on public.user_brackets;
create policy user_brackets_select_own
on public.user_brackets
for select
using (session_id = public.request_session_id());

drop policy if exists user_brackets_insert_own on public.user_brackets;
create policy user_brackets_insert_own
on public.user_brackets
for insert
with check (
  public.request_session_id() is not null
  and session_id = public.request_session_id()
);

drop policy if exists user_brackets_update_own on public.user_brackets;
create policy user_brackets_update_own
on public.user_brackets
for update
using (session_id = public.request_session_id())
with check (session_id = public.request_session_id());

drop policy if exists user_brackets_delete_own on public.user_brackets;
create policy user_brackets_delete_own
on public.user_brackets
for delete
using (session_id = public.request_session_id());

-- user_picks scoped through parent bracket ownership

drop policy if exists user_picks_select_own on public.user_picks;
create policy user_picks_select_own
on public.user_picks
for select
using (
  exists (
    select 1
    from public.user_brackets b
    where b.id = user_picks.bracket_id
      and b.session_id = public.request_session_id()
  )
);

drop policy if exists user_picks_insert_own on public.user_picks;
create policy user_picks_insert_own
on public.user_picks
for insert
with check (
  public.request_session_id() is not null
  and exists (
    select 1
    from public.user_brackets b
    where b.id = user_picks.bracket_id
      and b.session_id = public.request_session_id()
  )
);

drop policy if exists user_picks_update_own on public.user_picks;
create policy user_picks_update_own
on public.user_picks
for update
using (
  exists (
    select 1
    from public.user_brackets b
    where b.id = user_picks.bracket_id
      and b.session_id = public.request_session_id()
  )
)
with check (
  exists (
    select 1
    from public.user_brackets b
    where b.id = user_picks.bracket_id
      and b.session_id = public.request_session_id()
  )
);

drop policy if exists user_picks_delete_own on public.user_picks;
create policy user_picks_delete_own
on public.user_picks
for delete
using (
  exists (
    select 1
    from public.user_brackets b
    where b.id = user_picks.bracket_id
      and b.session_id = public.request_session_id()
  )
);

commit;
